const VALIDATION_METADATA = Symbol.for('class-validator:metadata');

function ensurePropertyMetadata(target, propertyKey) {
  const ctor = target.constructor;
  if (!Object.prototype.hasOwnProperty.call(ctor, VALIDATION_METADATA)) {
    Object.defineProperty(ctor, VALIDATION_METADATA, {
      value: new Map(),
      enumerable: false,
      configurable: false,
      writable: false,
    });
  }
  const store = ctor[VALIDATION_METADATA];
  if (!store.has(propertyKey)) {
    store.set(propertyKey, {
      optional: false,
      validators: [],
    });
  }
  return store.get(propertyKey);
}

function addValidator(target, propertyKey, validator) {
  const metadata = ensurePropertyMetadata(target, propertyKey);
  metadata.validators.push(validator);
}

function getMetadata(target) {
  const metadata = new Map();
  let ctor = target.constructor;
  while (ctor && ctor !== Object) {
    const store = ctor[VALIDATION_METADATA];
    if (store) {
      for (const [propertyKey, value] of store.entries()) {
        if (!metadata.has(propertyKey)) {
          metadata.set(propertyKey, { optional: value.optional, validators: [...value.validators] });
        }
      }
    }
    ctor = Object.getPrototypeOf(ctor);
  }
  return metadata;
}

class ValidationError {
  constructor(init = {}) {
    this.property = init.property || '';
    if (init.constraints) {
      this.constraints = init.constraints;
    }
    if (init.children) {
      this.children = init.children;
    }
  }
}

function createError(property, messages) {
  const constraints = {};
  messages.forEach((message, index) => {
    constraints[`constraint_${index + 1}`] = message;
  });
  return new ValidationError({ property, constraints });
}

function validateValue(property, value, metadata, object) {
  if ((value === undefined || value === null) && metadata.optional) {
    return [];
  }

  const messages = [];
  for (const validator of metadata.validators) {
    if (!validator.validate(value, object)) {
      messages.push(typeof validator.message === 'function' ? validator.message(property) : validator.message);
    }
  }
  return messages;
}

function validateSync(object) {
  if (object === null || typeof object !== 'object') {
    return [
      new ValidationError({
        property: '',
        constraints: { constraint_1: 'Validation payload must be an object.' },
      }),
    ];
  }

  const metadata = getMetadata(object);
  const errors = [];

  for (const [property, propertyMeta] of metadata.entries()) {
    const value = object[property];
    const messages = validateValue(property, value, propertyMeta, object);
    if (messages.length > 0) {
      errors.push(createError(property, messages));
    }
  }

  return errors;
}

async function validate(object) {
  return validateSync(object);
}

function withDefaultMessage(messageOrFactory, defaultFactory) {
  if (messageOrFactory && typeof messageOrFactory.message === 'string') {
    return messageOrFactory.message;
  }
  if (typeof messageOrFactory === 'string') {
    return messageOrFactory;
  }
  return defaultFactory;
}

function IsOptional() {
  return function (target, propertyKey) {
    const metadata = ensurePropertyMetadata(target, propertyKey);
    metadata.optional = true;
  };
}

function IsString(options = {}) {
  return function (target, propertyKey) {
    addValidator(target, propertyKey, {
      name: 'isString',
      message: withDefaultMessage(options, `${propertyKey} must be a string.`),
      validate: (value) => typeof value === 'string',
    });
  };
}

function IsNotEmpty(options = {}) {
  return function (target, propertyKey) {
    addValidator(target, propertyKey, {
      name: 'isNotEmpty',
      message: withDefaultMessage(options, `${propertyKey} should not be empty.`),
      validate: (value) => typeof value === 'string' && value.trim().length > 0,
    });
  };
}

function MinLength(length, options = {}) {
  return function (target, propertyKey) {
    addValidator(target, propertyKey, {
      name: 'minLength',
      message: withDefaultMessage(options, `${propertyKey} must be at least ${length} characters.`),
      validate: (value) => typeof value === 'string' && value.length >= length,
    });
  };
}

function MaxLength(length, options = {}) {
  return function (target, propertyKey) {
    addValidator(target, propertyKey, {
      name: 'maxLength',
      message: withDefaultMessage(options, `${propertyKey} must be at most ${length} characters.`),
      validate: (value) => typeof value === 'string' && value.length <= length,
    });
  };
}

function Matches(pattern, options = {}) {
  return function (target, propertyKey) {
    addValidator(target, propertyKey, {
      name: 'matches',
      message: withDefaultMessage(options, `${propertyKey} has an invalid format.`),
      validate: (value) => typeof value === 'string' && pattern.test(value),
    });
  };
}

function IsEmail(options = {}) {
  const regex = /^[^\s@]+@[^\s@]+\.[^\s@]+$/;
  return function (target, propertyKey) {
    addValidator(target, propertyKey, {
      name: 'isEmail',
      message: withDefaultMessage(options, `${propertyKey} must be a valid email address.`),
      validate: (value) => typeof value === 'string' && regex.test(value),
    });
  };
}

function IsEnum(enumObj, options = {}) {
  const values = Object.values(enumObj);
  return function (target, propertyKey) {
    addValidator(target, propertyKey, {
      name: 'isEnum',
      message: withDefaultMessage(options, `${propertyKey} must be a valid value.`),
      validate: (value) => values.includes(value),
    });
  };
}

function IsIn(values, options = {}) {
  return function (target, propertyKey) {
    addValidator(target, propertyKey, {
      name: 'isIn',
      message: withDefaultMessage(options, `${propertyKey} must be one of the allowed values.`),
      validate: (value) => values.includes(value),
    });
  };
}

function IsInt(options = {}) {
  return function (target, propertyKey) {
    addValidator(target, propertyKey, {
      name: 'isInt',
      message: withDefaultMessage(options, `${propertyKey} must be an integer.`),
      validate: (value) => typeof value === 'number' && Number.isInteger(value),
    });
  };
}

function Min(minValue, options = {}) {
  return function (target, propertyKey) {
    addValidator(target, propertyKey, {
      name: 'min',
      message: withDefaultMessage(options, `${propertyKey} must be greater than or equal to ${minValue}.`),
      validate: (value) => typeof value === 'number' && value >= minValue,
    });
  };
}

function Max(maxValue, options = {}) {
  return function (target, propertyKey) {
    addValidator(target, propertyKey, {
      name: 'max',
      message: withDefaultMessage(options, `${propertyKey} must be less than or equal to ${maxValue}.`),
      validate: (value) => typeof value === 'number' && value <= maxValue,
    });
  };
}

function IsArray(options = {}) {
  return function (target, propertyKey) {
    addValidator(target, propertyKey, {
      name: 'isArray',
      message: withDefaultMessage(options, `${propertyKey} must be an array.`),
      validate: (value) => Array.isArray(value),
    });
  };
}

function ArrayMinSize(size, options = {}) {
  return function (target, propertyKey) {
    addValidator(target, propertyKey, {
      name: 'arrayMinSize',
      message: withDefaultMessage(options, `${propertyKey} must contain at least ${size} elements.`),
      validate: (value) => Array.isArray(value) && value.length >= size,
    });
  };
}

function IsDefined(options = {}) {
  return function (target, propertyKey) {
    addValidator(target, propertyKey, {
      name: 'isDefined',
      message: withDefaultMessage(options, `${propertyKey} should not be null or undefined.`),
      validate: (value) => value !== undefined && value !== null,
    });
  };
}

function IsObject(options = {}) {
  return function (target, propertyKey) {
    addValidator(target, propertyKey, {
      name: 'isObject',
      message: withDefaultMessage(options, `${propertyKey} must be an object.`),
      validate: (value) => value !== null && typeof value === 'object' && !Array.isArray(value),
    });
  };
}

module.exports = {
  ValidationError,
  validate,
  validateSync,
  IsOptional,
  IsString,
  IsNotEmpty,
  MinLength,
  MaxLength,
  Matches,
  IsEmail,
  IsEnum,
  IsIn,
  IsInt,
  Min,
  Max,
  IsArray,
  ArrayMinSize,
  IsDefined,
  IsObject,
};
